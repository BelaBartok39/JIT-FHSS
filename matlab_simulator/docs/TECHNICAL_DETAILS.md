# JIT-FHSS Technical Documentation

## System Overview

The Just-In-Time Frequency Hopping Spread Spectrum (JIT-FHSS) simulator models a satellite communication system where frequency hopping patterns are generated by an external central source and distributed to both transmitter and receiver just before use.

## Architecture Components

### 1. CentralSourceManager (`CentralSourceManager.m`)

**Purpose**: Manages multiple redundant pattern generation sources with automatic failover.

**Key Features:**
- Multiple independent pattern sources (simulating geographically distributed servers)
- High-entropy random pattern generation (simulating TRNG)
- Automatic failover on source failure/jamming
- Fallback cache with PRNG-based patterns
- Pattern sequence numbering for synchronization

**Implementation Details:**

```matlab
classdef CentralSourceManager < handle
    properties
        numSources          % Number of redundant sources
        sourcesActive       % Boolean array of source status
        currentSourceIdx    % Active source index
        patternCache        % Fallback patterns
        patternSequence     % Monotonically increasing sequence number
    end
```

**Pattern Generation Algorithm:**

1. Check current source availability
2. If unavailable, attempt failover to next source
3. If all sources down, use fallback cache
4. Generate pattern with:
   - Random frequency from available band
   - Current timestamp
   - Unique sequence number
   - Source ID

**Failover Logic:**
```
For each pattern request:
    attempts = 0
    while attempts < numSources:
        if current_source is active and not jammed:
            return generate_pattern()
        else:
            switch to next source
            attempts++

    # All sources failed
    return fallback_cache_pattern()
```

### 2. PatternBuffer (`PatternBuffer.m`)

**Purpose**: Manages pattern buffering and synchronization between central source and endpoints.

**Key Features:**
- Ordered pattern storage by sequence number
- Out-of-order packet handling
- Buffer level monitoring
- Old pattern cleanup
- Clock offset compensation

**Buffer Management:**

```
Buffer States:
- Full: bufferLevel = bufferSize (no more patterns can be added)
- Healthy: bufferLevel > bufferThreshold (normal operation)
- Low: bufferLevel ≤ bufferThreshold (trigger pattern request)
- Empty: bufferLevel = 0 (critical - no patterns available)
```

**Synchronization Mechanism:**

Patterns are ordered by sequence number, not timestamp. This handles:
- Out-of-order arrival due to network delays
- Clock synchronization errors
- Packet loss detection

```matlab
% Add pattern with ordering
function success = addPattern(obj, pattern)
    if pattern.sequenceNumber <= obj.lastSequenceNumber
        warning('Duplicate/out-of-order pattern');
        return false;
    end

    obj.patterns(end+1) = pattern;
    [~, sortIdx] = sort([obj.patterns.sequenceNumber]);
    obj.patterns = obj.patterns(sortIdx);
end
```

### 3. OrbitModel (`OrbitModel.m`)

**Purpose**: Models circular LEO satellite orbit and calculates geometry.

**Simplified Orbital Mechanics:**

Uses circular orbit assumption (eccentricity = 0):

```
Orbital radius: r = R_earth + altitude
Orbital velocity: v = sqrt(μ/r)
Orbital period: T = 2π√(r³/μ)

where μ = 398,600 km³/s² (Earth's gravitational parameter)
```

**Position Calculation:**

```matlab
% True anomaly (angle in orbit)
theta = (2π/T) * t

% Position in orbital plane
x = r * cos(theta)
y = r * sin(theta)
z = 0

% Rotate by inclination
pos = [x; y*cos(i); y*sin(i)]
```

**Range Calculation:**

```
Ground station position (spherical):
gs_x = R_earth * cos(lat) * cos(lon)
gs_y = R_earth * cos(lat) * sin(lon)
gs_z = R_earth * sin(lat)

Range vector:
range_vec = satellite_pos - gs_pos
range = ||range_vec||
```

**Range Rate (Radial Velocity):**

```matlab
% Dot product of velocity with range unit vector
range_rate = dot(velocity, range_vec) / range

% Positive = approaching (satellite getting closer)
% Negative = receding (satellite moving away)
```

**Visibility Calculation:**

Satellite is visible if elevation angle > minimum (typically 5-10°):

```
elevation = arcsin(height / range)
visible = (elevation >= min_elevation)
```

**Limitations:**
- Assumes circular orbit (real orbits have eccentricity)
- Simplified Earth rotation (not modeled)
- No atmospheric effects
- No orbital perturbations

### 4. DopplerModel (`DopplerModel.m`)

**Purpose**: Calculates and compensates for Doppler frequency shift.

**Doppler Shift Formula:**

```
Classical Doppler for electromagnetic waves:
f_observed = f_source * (c + v_observer) / (c + v_source)

For v << c (satellite velocities ~7 km/s << 300,000 km/s):
Δf ≈ f_source * (v_radial / c)

where:
- f_source = transmitted frequency
- v_radial = range rate (positive if approaching)
- c = speed of light
```

**Implementation:**

```matlab
function dopplerShift = calculateDopplerShift(obj, transmitFreq, rangeRate)
    % Convert range rate to m/s
    rangeRate_ms = rangeRate * 1000;

    % Doppler shift
    dopplerShift = transmitFreq * (rangeRate_ms / obj.speedOfLight);
end
```

**Example Calculation:**

```
Given:
- Carrier frequency: 2.05 GHz
- Range rate: +4 km/s (approaching)
- Speed of light: 3×10⁸ m/s

Doppler shift:
Δf = 2.05×10⁹ * (4000 / 3×10⁸)
   = 2.05×10⁹ * 1.33×10⁻⁵
   = 27,300 Hz = 27.3 kHz

Received frequency:
f_rx = 2.050027 GHz
```

**Compensation at Receiver:**

```matlab
% Receiver knows:
% 1. Expected transmit frequency (from pattern)
% 2. Satellite range rate (from tracking)

% Calculate expected Doppler
expected_shift = calculateDopplerShift(transmit_freq, range_rate);

% Remove Doppler from received signal
actual_freq = received_freq - expected_shift;

% Compare with expected to detect sync errors
error = abs(actual_freq - transmit_freq);
```

**Propagation Delay:**

```matlab
% One-way delay
delay = range / c

% Round-trip (important for pattern distribution)
RTT = 2 * range / c

Example for range = 1500 km:
delay = 1500000 / 3×10⁸ = 5 ms
RTT = 10 ms
```

### 5. SatelliteSender (`SatelliteSender.m`)

**Purpose**: Satellite transmitter that hops frequencies according to buffered patterns.

**Operational Flow:**

```
1. Initialization:
   - Create orbit model
   - Create pattern buffer
   - Request initial patterns from central source

2. Pattern Request:
   for each pattern:
       - Get pattern from central source
       - Calculate uplink delay
       - Adjust pattern timestamp for delay
       - Add to buffer

3. Transmission (called each time step):
   if time_since_last_hop >= hop_duration:
       - Get next pattern from buffer
       - Switch to new frequency
       - Check buffer level, request more if low

   - Transmit data on current frequency
   - Calculate Doppler shift
   - Log transmission parameters

4. Logging:
   - Time, frequencies, Doppler, range, range rate
   - Used for analysis and receiver synchronization
```

**Buffer Management:**

```matlab
% Check buffer level periodically
if buffer.getBufferLevel() < bufferThreshold:
    requestPatterns(centralSource, 10)  % Request 10 more patterns

% Clear old patterns to free memory
if buffer.getBufferLevel() is high:
    buffer.clearOldPatterns()
```

### 6. GroundReceiver (`GroundReceiver.m`)

**Purpose**: Ground station receiver that decodes FHSS signals.

**Reception Process:**

```
1. Pattern Synchronization:
   - Maintain same pattern buffer as sender
   - Hop to frequencies in sync with sender

2. Signal Reception:
   - Receive signal at Doppler-shifted frequency
   - Know expected transmit frequency from pattern
   - Calculate expected Doppler from satellite tracking

3. Doppler Compensation:
   compensated_freq = received_freq - expected_doppler

4. Frequency Matching:
   error = |compensated_freq - expected_freq|
   if error < tolerance:
       decode successful
   else:
       synchronization error

5. Logging:
   - Record success/failure
   - Log frequency errors for analysis
```

**Synchronization Requirements:**

For successful reception:
1. **Pattern Sync**: Same pattern sequence as sender
2. **Time Sync**: Hop at same time (within tolerance)
3. **Frequency Sync**: After Doppler compensation, frequencies match

**Error Sources:**

- **Pattern desync**: Different sequence numbers
  - Cause: Packet loss, buffer exhaustion
  - Detection: Sequence number mismatch

- **Time desync**: Hop timing offset
  - Cause: Clock drift, processing delay
  - Detection: Frequency error pattern

- **Doppler error**: Incorrect compensation
  - Cause: Tracking error, outdated ephemeris
  - Detection: Consistent frequency offset

## Simulation Flow

### Main Loop (`run_simulation.m`)

```
Initialize:
    - Create central source manager
    - Create orbit model
    - Create satellite sender
    - Create ground receiver
    - Pre-load pattern buffers

For each time step:
    1. Update time for all components

    2. Apply jamming scenarios (if configured)

    3. Check buffer levels:
       if buffer_low:
           request more patterns from central source

    4. Check satellite visibility:
       if visible:
           # Satellite transmits
           satellite.transmit(data)

           # Get transmission parameters
           get last transmission from log

           # Receiver attempts decode
           receiver.receive(transmitted_signal)

           # Track success/failure

    5. Log metrics

Post-simulation:
    - Calculate statistics
    - Save results
```

### Timing Considerations

**Time Step Selection:**
```
timeStep = 0.1 s  (10 Hz update rate)

Chosen because:
- Doppler changes slowly (seconds timescale)
- Orbital motion is gradual
- Hop duration is 1.0 s
- 10 samples per hop provides smooth data
```

**Hop Duration Selection:**
```
hopDuration = 1.0 s

Tradeoffs:
- Shorter: More difficult sync, higher data rate capability
- Longer: Easier sync, more vulnerable to jamming on single frequency
- 1.0 s is typical for tactical FHSS systems
```

## Performance Metrics

### Success Rate

```matlab
success_rate = successful_receptions / total_transmissions

Target: >99%

Factors affecting success:
- Buffer exhaustion: 0%
- Sync error: <1%
- Doppler error: <0.1%
```

### Frequency Error

```matlab
freq_error = |compensated_freq - expected_freq|

Acceptable: < 0.1% of channel spacing

For 100 channels over 100 MHz:
Channel spacing = 1 MHz
Max error = 1 kHz
```

### Doppler Statistics

```matlab
max_doppler = max(abs(doppler_shifts))
mean_doppler = mean(abs(doppler_shifts))

For LEO at 500 km, 2 GHz carrier:
Max: ~30 kHz
Mean: ~15 kHz
```

### Buffer Utilization

```matlab
buffer_utilization = min(buffer_level) / buffer_size

Target: >20% (never completely empty)

Low utilization indicates:
- Pattern generation problems
- Source failures
- Request timing issues
```

## Testing & Validation

### Unit Tests

Each component should be tested independently:

```matlab
% Test CentralSourceManager
csm = CentralSourceManager(3, 100, [2e9, 2.1e9], 1000);
pattern = csm.generatePattern(0);
assert(pattern.frequency >= 2e9 && pattern.frequency <= 2.1e9);

% Test OrbitModel
orbit = OrbitModel(500, 45, 37.4, -122.1);
[range, rangeRate] = orbit.getRangeToGroundStation(0);
assert(range > 500);  % Must be at least altitude

% Test DopplerModel
doppler = DopplerModel();
shift = doppler.calculateDopplerShift(2e9, 4);
assert(abs(shift - 26667) < 100);  % ~26.7 kHz expected
```

### Integration Tests

```matlab
% Test full communication chain
[success, decoded] = simulateTransmission();
assert(success == true);
assert(decoded == transmitted_data);
```

### Scenario Tests

```matlab
% Test failover
jam primary source
verify automatic failover
verify continued operation

% Test buffer exhaustion
stop pattern generation
verify fallback cache usage
verify graceful degradation
```

## Future Enhancements

### 1. Realistic Channel Model
- Add AWGN (Additive White Gaussian Noise)
- Model atmospheric attenuation
- Include multipath effects

### 2. Advanced Orbital Mechanics
- Elliptical orbits
- Orbital perturbations (J2, drag)
- Earth rotation
- Multiple ground stations

### 3. Adaptive Hopping
- Interference detection
- Dynamic frequency exclusion
- Rate adaptation

### 4. Security Analysis
- Pattern predictability metrics
- Entropy calculations
- Anti-jamming effectiveness

### 5. Multiple Satellites
- Constellation simulation
- Handover modeling
- Frequency coordination

## Appendix: Key Equations

**Circular Orbital Velocity:**
```
v = √(μ/r)
where μ = GM = 398600 km³/s²
```

**Doppler Shift:**
```
Δf = f₀ × (v_r / c)
```

**Propagation Delay:**
```
τ = range / c
where c = 2.998×10⁸ m/s
```

**Link Budget (not implemented, but relevant):**
```
P_rx = P_tx + G_tx + G_rx - L_path - L_atm
L_path = 20×log₁₀(4πR/λ)  [Friis equation]
```

**Elevation Angle:**
```
elevation = arcsin((h_sat - h_gs) / range)
```
